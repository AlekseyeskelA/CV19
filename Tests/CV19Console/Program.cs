using System;
using System.Collections.Generic;
using System.Threading;

namespace CV19Console
{
    internal class Program
    {
        private static bool _ThreadUndate = true;

        static void Main(string[] args)
        {
            /* Внутри пространства имён System.Threading есть главный класс Thread, который отвечает за потоки. Он позволяет осуществлять менеджмент потоков.
             * У него есть надор статических методов и свойств, через которые можно осуществить доступ к потокам и их управление.
             * Кроме того, сам класс предствавляет собой обычнцй класс, экземпляр которого можно создать. То есть просто создаётся объект "Поток", и ему
             * указывается точка входа вторичного потока, из которого и начнётся выполнение. При этом мы получаем объект Thread, который позволяет
             * осуществлять контроль за процессом работы вашего потока. При этом сам объект, когда он только создан, не запускает поток. Он всего лишь
             * осуществляет управление потоком, которого на текущий момент по сути нет. Класс Thread позволяет создать поток в программе.
             * Следует понимать, что процесс создания потока подразумевает выделение памяти как минимум на хранение объекта потока и на информапцию о самом
             * потоке. Также запуск самого потока, как и его завершение, это двольно длительная операция. Т.е., если многократно в короткие моменты времени
             * создавать потоки, то это существенно замедлит приложение. Поэтому имеет смысл один раз создать поток и потом выполнять работу в нём.
             * В ряде случаев по такому принципу реализованы менеджеры потоков, которые, например, создают один поток, а дальше все операции, которые
             * поручаются, выполняются этим менеджером в его собственном потоке.*/

            Thread.CurrentThread.Name = "Main thread";              // Зададим имя основному потоку.

            var clock_thread = new Thread(ThreadMethod);
            clock_thread.Name = "Other thread";                           // Зададим имя нашему потоку.            

            /*thread.Start()*/;                                         // Для того, чтобы стартовать поток, нужно вызвать метод Start() у объекта thread.

            /* После этого поток начинает выполняться, и выполняется в пределах метожа ThreadMothod(). По сути, это будет процедурой Main для нашего потока.
             * Когда метод ThreadMothod() завершается, то и поток тоже становится завершённым.
             * При этом наши потоки блокируют работу процесса, т.е пока все потоки не завершатся, наше приложение также не завершится. Это происходит потому,
             * что все потоки, которые мы создаём таким образом, являются главными. Номера потоков - это нумерация потоков в пределах процесса.
             * Однако, можно назначить поток фоновым, т.е. понизить его  в правах. И при этом операционная система сможет выгрузить процесс
             * даже если в нём есть фоновые потоки. Для этого понадобится устанговить свойство IsBackground = true. В этом случае поток перестанет
             * блокировать выгрузку нашего процесса. Т.е. если есть задача создать какой-то поток, который наблюдает за чем-то, например, watchdog, 
             * т.е. поток, который следит за тем, чтобы другой поток не завис, либо поток логирования, который также может в непрерывном цикле обрабатывать
             * какую-то коллекцию, и при обнаружении новых объектов в этой коллекции, записывать их в журнал, то етому потоку необходимо выставить свойство
             * IsBackground = true, и после этого он не будет нам мешаться:*/

            clock_thread.IsBackground = true;                             // В этом случае поток перестанет блокировать выгрузку нашего процесса.

            /* Можно выставить приоритет потока. В среде .Net предоставляется 5 вариантов приоритетов. В операционной системе существует 24 приоритета.
             * При этом приоритет потоков учитывается на уровне всей операпционной системы, т.е. потоки конкурируют за время процессора в соответствии
             * со своим приоритетом не только внутри нашего приложения, но и с процессами других приложений. Если у нас поток выполняет какую-то
             * короткую операцию, и должен сделать это быстро, то нужно задать ему повышенный приоритет, наприме, AboveNormal. Если это поток, действия 
             * которого не важны и должны ваыполняться во вторую очередь, то этому потоку имеет смысл занизить приоритет. Но работа с приоритетами это
             * такая вещь, к которой можно прийти, если все другие инструменты уже исчерпаны, либо если есть понимание, что мы делаем. В этом случае
             * приоритеты помогут.*/

            clock_thread.Priority = ThreadPriority.AboveNormal;

            //thread.Start();

            /* В классе Thread можно передать информацию внутрь потока при его старте. Для этого можно воспользоваться перегрузкой конструктора,
             * которая принимает другой тип делегата. Т.е. делегат может принимать объект с качестве параметра. Параметр при этом нужно передать
             * методу Start(). Дале в методе потока нужно приводить его в нужному типу:*/
            
            clock_thread.Start(42);

            /* Допустим, что у нас есть набор данных, и нам эти данные нужно передать в метод PrintMethod потока: */

            var count = 5;
            var msg = "HelloWolrd!";
            var timeout = 150;

            /* Создаём объект Thread, не записывая его не в какие переменные (его сборщик мусора не удалит, пока поток не завершится). 
             Используем внутри лямба-выражение, с помощью которого вызываем метод: */

            new Thread(() => PrintMethod(msg, count, timeout)) { IsBackground = true }.Start();

            CheckThread();

            /* Задача отладки многопоточных приложений может оказаться сложной. Это становится онятным, если добавить пару циклов, одни из которых
             * находится внутри созданного нами потока. Кроме того, ошибки, который могут произойти в результате доступа двух потоков к одному ресурсу,
             * в режиме пошаговой отладки перехватить невозможно. Помочь может панель "Место отлалдки", "Поток", в которой можно переключаться между
             * потоками в режиме отладки.*/

            //for (var i = 0; i < 100; i++)
            //    Console.WriteLine(i);

            /* Когда в нашем приложении существуют множество потоков, то возникает ряд проблем, связанных с их взаимодействием между собой, особенно, если потоки
             * взаимодействуют с каким-то ресурсом, целостность которого является проблемой в многопоточном приложении. Каждый поток выполняет набор инструкций,
             * причём набор инструкций, который мы прописываем, не является атомарным, т.е. каждая инструкция внутри себя может содержать инструкции более низкого
             * уровня. Например, часто можно встретить работу со списком в потоках, когда у нас есть список значений, и 10 потоков, которые записывают данные в
             * этот список. При этом, обращение каждого потока на добавдление элемента внутрь списка пораждает внутри списка ряд операций, которые он должен
             * выполнить, и если один поток начал процесс добавления элемента в список и был прерван в процессе, и в это время второй поток точно также выполняет
             * некоторые действия над этим списком, то можно получить очень неожиданные результаты: */

            var values = new List<int>();                           // Список.

            var threads = new Thread[10];                           // Создадим 10 потоков.

            /* В этом цикле должна происходить ошибка, из-за одновременного обращения к списку нескольких потоков (почему-то у меня ошибки не возникает).
             * Ресурсы, к которым обращаются множество потоков обычно называются "Критической секцией". Чтобы избавиться от ошибки можно использовать специальные
             * коллекции, которые защищены от многопоточного доступа. Они находятся в пространстве имён System.Collections.Concurent. Это ConcurentBag, либо
             * ConcurentQueue. Также есть ConcurentDictionary. Если не использовать данные коллекции, то критическую секцию нужно блокировать. Причём блокировать
             * нужно именно в момент, когда работа происходит внутри критической секции. Критической секция у нас является список values. Его и надо заблокировать.
             * К списку мы обращаемся внутри цикла. Можно зоблокировать цикл, но тогда исчезнет асинхронность, т.е. приложение останется многопоточным, но
             * все потоки будут выполняться последовательно, а не параллельно. Для этого воспользуемся специальным синтаксическим сахаром - оператором loc,
             * внутри которого нужно указать объект ссылочного типа, на котором будет выполняться блокировка. Но часто можно видеть создание специального объекта
             * (object lock_object) ждя блокировки:*/

            object lock_object = new object();
            for (var i = 0; i < threads.Length; i++)
                threads[i] = new Thread(() =>
                {
                    for (var j = 0; j < 10; j++)
                    {
                        // Уточнить кончструкцию! Работает не стабильно:
                        //lock (values)
                        lock (lock_object)
                        {
                            values.Add(Thread.CurrentThread.ManagedThreadId);
                        }
                        Thread.Sleep(1);
                    }
                });

            /* Не всегда можно использовать оператор lock. Если работать в асинхронном приложении с использованием TLP (async/await), и у нас есть асинхронный
             * метод, то внутри этого метода конструкцию lock использовать не получится. Кроме того, существуют такие сложные сценарии многопоточной обработки,
             * когда заблокировать критическую секцию надо в одном потоке, а разблокировать надо в другом потоке, и здесь конструкция lock тоже не поможет.
             * В этом случае надо понимать, как она устроена. Устроеан она также как и цикл foreach или конструкция using. Она разворачивается компилятором
             * в набор директив на C#. Выглядит это следующим образом. Внутри лежит класс Monitor. Именно он осуществляет блокировку критической секции.
             * У него есть метод Enter() - вход в критическую секцию. При этом метод Enter() блокирует процесс выполнения потока до тех пор, пока
             * критический объект lock_object не будет разблокирован в другом месте. Т.е. до тех пор, пока потоки занимаются добавлением данных в список,
             * главный поток будет заблокирован и продолжит выполнение после того, как очередной из потоков выйдет из критической секции.*/

            Monitor.Enter(lock_object);                             // Напчинается выполнение оператора lock с блокировки.
            try                                                     // try освобождает критическую секцию даже в том случае, если у нас при работе внутри неё
                                                                    // происходит какая-то ошибка (исключение). В блоке try находится критическая секция.
            {

            }
            finally                                                 // в блоке finaly происходит выход из блокировки.
            {
                Monitor.Exit(lock_object);
            }

            /* Таким образом можно самостоятельно имитировать работу оператора lock? используя  Monitor.Enter и Monitor.Exit используя их в разныч частях
             * программы, в разных потоках или в другой части асинхронного метода, но при этом желательно использовать конструкцию try/finaly, чтобы
             * не образовать мёртвых блокировок. Таким образом при взаимодействии с потоками придётся использовать ряд примитивов, причём очень низкоуровневых,
             * и большинство их них находятся даже не на уровне платформы .Net, а лежат внутри ядра операционной системы. Т.е. это очень глубокие механизмы,
             * с которыми взаимодействует платформа .Net, предоставляя свой уровень абстракции. Методы Enter и Exit внутри себя порождают ряд более сложных
             * операций. */

            foreach (var thread1 in threads)
                thread1.Start();

            /* Существует также прямая остановка потока. См. метод ThreadMethod(). Это не безопасный вариант. Есть возможность синхронизироваться с потоком.
             * Допустим, что в приложении одновременно выполняется два потока команд. В ряде сценариев может потребоваться, чтобы один поток дождался, пока
             * другой поток не завершится, и после этого продолжил свою работу. В этом случае нужно обладать ссылкой на объект потока, который нужно дождаться,
             * и у него есть метод Join, который позволяет остановитьтекущий главный поток до того времени, пока вторичный поток не быдет завершён.
             * При этом можно ожидать его до бесконечности, либо можно передать в качестве параметра численное значение таймаута в милисекундах, которое
             * мы будем ждать. При этом метод Join нам вернёт либо истину (удалось синхронизироваться), либо ложь (не удалось).
             * Часто можно увидеть следующую конструкцию (до появления TPL).*/
            /* Если нам не удалось синхронизироваться за таймаут 100 мс (причём этот таймаут долден быть равет таймауту внутри потока, либо превышать его
             * в 2 раза, например, чтобы гарантировано поток имел возможность остановиться). */
            /* Если внктри потока в процессе остановки что-то пойдёт нитак, то его можно "прибить". Сделать это можно двумя способами: это вызвать метод
             * Abort(), или вызвать метод Interrupt().*/

            if (clock_thread.Join(100))
            {
                //clock_thread.Abort();                               // Прерывает поток в любой точке процесса его выполнения. Это может пагубно сказаться
                                                                    // на целостности объектов, которые используются внутри потока.
                                                                    // Сейчас этот метод заптещён внутри .Net.
                clock_thread.Interrupt();                           // Прерывает поток либо в нутри метода Sleep, либо внутри метода Spinwait().
                                                                    // Таким образом нарушить целостность объектов он не сможет.
                                                                    // ДАННЫХ МЕТОДОВ СТАРАЮТСЯ ИЗБЕГАТЬ В ПОЛЬЗУ МЯГКОЙ ОСТАНОВКИ.
            }

            // Вообще работой с потоками лучше пренебречь с пользу раоты с задачами.

            Console.WriteLine(string.Join(",", values));

            Console.ReadLine();
        }

        //private static void ThreadMethod()
        //{
        //    CheckThread();

        //    while(true)
        //    {
        //        Thread.Sleep(100);
        //        Console.Title = DateTime.Now.ToString();
        //    }
        //}

        private static void ThreadMethod(object parametr)
        {
            var value = (int)parametr;
            Console.WriteLine(value);
            Console.WriteLine(parametr);

            CheckThread();

            //while (true)
            /* Мягкая остановка. Если из другого потока сбросить флаг _ThreadUndate, то поток часов вывалится из этого цикла и завершится. Это называется
             * Мягкая остановка, и в ряде случаев поток, который мы пытаемся остановить таким образом, должен быть подвижным, и постоянно проверять этот флаг
             * Если в потоке выполняется какая-то длительная операция, которая сама по себе может повиснуть, то этот вариант работать на будет, или будет
             * не эффективным:*/
            while (_ThreadUndate)
            {
                Thread.Sleep(100);
                Console.Title = DateTime.Now.ToString();
            }
        }

        private static void PrintMethod(string Massage, int Count, int Timeout)
        {
            for (var i = 0; i < Count; i++)
            {
                Console.WriteLine(Massage);
                Thread.Sleep(Timeout);
                Thread.SpinWait(1000);
                Console.WriteLine(i);
            }
        }

        private static void CheckThread()
        {
            var thread = Thread.CurrentThread;
            Console.WriteLine("id:{0} - {1}", thread.ManagedThreadId, thread.Name);
        }
    }
}
