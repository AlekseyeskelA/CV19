using System;
using System.Threading;

namespace CV19Console
{
    internal class Program
    {
        static void Main(string[] args)
        {
            /* Внутри пространства имён System.Threading есть главный класс Thread, который отвечает за потоки. Он позволяет осуществлять менеджмент потоков.
             * У него есть надор статических методов и свойств, через которые можно осуществить доступ к потокам и их управление.
             * Кроме того, сам класс предствавляет собой обычнцй класс, экземпляр которого можно создать. То есть просто создаётся объект "Поток", и ему
             * указывается точка входа вторичного потока, из которого и начнётся выполнение. При этом мы получаем объект Thread, который позволяет
             * осуществлять контроль за процессом работы вашего потока. При этом сам объект, когда он только создан, не запускает поток. Он всего лишь
             * осуществляет управление потоком, которого на текущий момент по сути нет. Класс Thread позволяет создать поток в программе.
             * Следует понимать, что процесс создания потока подразумевает выделение памяти как минимум на хранение объекта потока и на информапцию о самом
             * потоке. Также запуск самого потока, как и его завершение, это двольно длительная операция. Т.е., если многократно в короткие моменты времени
             * создавать потоки, то это существенно замедлит приложение. Поэтому имеет смысл один раз создать поток и потом выполнять работу в нём.
             * В ряде случаев по такому принципу реализованы менеджеры потоков, которые, например, создают один поток, а дальше все операции, которые
             * поручаются, выполняются этим менеджером в его собственном потоке.*/

            Thread.CurrentThread.Name = "Main thread";              // Зададим имя основному потоку.

            var thread = new Thread(ThreadMethod);
            thread.Name = "Other thread";                           // Зададим имя нашему потоку.            

            /*thread.Start()*/;                                         // Для того, чтобы стартовать поток, нужно вызвать метод Start() у объекта thread.

            /* После этого поток начинает выполняться, и выполняется в пределах метожа ThreadMothod(). По сути, это будет процедурой Main для нашего потока.
             * Когда метод ThreadMothod() завершается, то и поток тоже становится завершённым.
             * При этом наши потоки блокируют работу процесса, т.е пока все потоки не завершатся, наше приложение также не завершится. Это происходит потому,
             * что все потоки, которые мы создаём таким образом, являются главными. Номера потоков - это нумерация потоков в пределах процесса.
             * Однако, можно назначить поток фоновым, т.е. понизить его  в правах. И при этом операционная система сможет выгрузить процесс
             * даже если в нём есть фоновые потоки. Для этого понадобится устанговить свойство IsBackground = true. В этом случае поток перестанет
             * блокировать выгрузку нашего процесса. Т.е. если есть задача создать какой-то поток, который наблюдает за чем-то, например, watchdog, 
             * т.е. поток, который следит за тем, чтобы другой поток не завис, либо поток логирования, который также может в непрерывном цикле обрабатывать
             * какую-то коллекцию, и при обнаружении новых объектов в этой коллекции, записывать их в журнал, то етому потоку необходимо выставить свойство
             * IsBackground = true, и после этого он не будет нам мешаться:*/

            thread.IsBackground = true;                             // В этом случае поток перестанет блокировать выгрузку нашего процесса.

            /* Можно выставить приоритет потока. В среде .Net предоставляется 5 вариантов приоритетов. В операционной системе существует 24 приоритета.
             * При этом приоритет потоков учитывается на уровне всей операпционной системы, т.е. потоки конкурируют за время процессора в соответствии
             * со своим приоритетом не только внутри нашего приложения, но и с процессами других приложений. Если у нас поток выполняет какую-то
             * короткую операцию, и должен сделать это быстро, то нужно задать ему повышенный приоритет, наприме, AboveNormal. Если это поток, действия 
             * которого не важны и должны ваыполняться во вторую очередь, то этому потоку имеет смысл занизить приоритет. Но работа с приоритетами это
             * такая вещь, к которой можно прийти, если все другие инструменты уже исчерпаны, либо если есть понимание, что мы делаем. В этом случае
             * приоритеты помогут.*/

            thread.Priority = ThreadPriority.AboveNormal;

            //thread.Start();

            /* В классе Thread можно передать информацию внутрь потока при его старте. Для этого можно воспользоваться перегрузкой конструктора,
             * которая принимает другой тип делегата. Т.е. делегат может принимать объект с качестве параметра. Параметр при этом нужно передать
             * методу Start(). Дале в методе потока нужно приводить его в нужному типу:*/
            thread.Start("d");

            CheckThread();

            /* Задача отладки многопоточных приложений может оказаться сложной. Это становится онятным, если добавить пару циклов, одни из которых
             * находится внутри созданного нами потока. Кроме того, ошибки, который могут произойти в результате доступа двух потоков к одному ресурсу,
             * в режиме пошаговой отладки перехватить невозможно. Помочь может панель "Место отлалдки", "Поток", в которой можно переключаться между
             * потоками в режиме отладки.*/

            //for (var i = 0; i < 100; i++)
            //    Console.WriteLine(i);

            Console.ReadLine();
        }

        //private static void ThreadMethod()
        //{
        //    CheckThread();

        //    while(true)
        //    {
        //        Thread.Sleep(100);
        //        Console.Title = DateTime.Now.ToString();
        //    }
        //}

        private static void ThreadMethod(object parametr)
        {
            var value = (int)parametr;
            Console.WriteLine(value);
            Console.WriteLine(parametr);

            CheckThread();

            while (true)
            {
                Thread.Sleep(100);
                Console.Title = DateTime.Now.ToString();
            }
        }

        private static void CheckThread()
        {
            var thread = Thread.CurrentThread;
            Console.WriteLine("id:{0} - {1}", thread.ManagedThreadId, thread.Name);
        }
    }
}
