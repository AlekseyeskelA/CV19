//#define Введение
//#define Многопоточность_и_отладка
//#define Передача_информации_в_поток
//#define Взаимодействие_потоков
//#define Мягкая_остановка_потока
//#define Прямая_или_жёсткая_остановка_потока
//#define Базовые_примитивы_блокировки_и_взаимной_синхронизации_потоков
//#define Защита_метода_от_многопоточности
#define Запуск_CV19Web_WebServer

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;

namespace CV19Console
{
    internal class Program
    {
#if Введение
        // Работой с потоками лучше пренебречь с пользу работы с задачами.
        static void Main(string[] args)
        {
            /* Внутри пространства имён System.Threading есть главный класс Thread, который отвечает за потоки. Он позволяет осуществлять менеджмент потоков.
             * У него есть надор статических методов и свойств, через которые можно осуществить доступ к потокам и их управление.
             * Кроме того, сам класс предствавляет собой обычнцй класс, экземпляр которого можно создать. То есть просто создаётся объект "Поток", и ему
             * указывается точка входа вторичного потока, из которого и начнётся выполнение. При этом мы получаем объект Thread, который позволяет
             * осуществлять контроль за процессом работы вашего потока. При этом сам объект, когда он только создан, не запускает поток. Он всего лишь
             * осуществляет управление потоком, которого на текущий момент по сути нет. Класс Thread позволяет создать поток в программе.
             * Следует понимать, что процесс создания потока подразумевает выделение памяти как минимум на хранение объекта потока и на информапцию о самом
             * потоке. Также запуск самого потока, как и его завершение, это двольно длительная операция. Т.е., если многократно в короткие моменты времени
             * создавать потоки, то это существенно замедлит приложение. Поэтому имеет смысл один раз создать поток и потом выполнять работу в нём.
             * В ряде случаев по такому принципу реализованы менеджеры потоков, которые, например, создают один поток, а дальше все операции, которые
             * поручаются, выполняются этим менеджером в его собственном потоке.*/

            Thread.CurrentThread.Name = "Main thread";              // Зададим имя основному потоку.

            var thread = new Thread(ThreadMethod);
            thread.Name = "Other thread";                           // Зададим имя нашему потоку.            

            thread.Start();                                         // Для того, чтобы стартовать поток, нужно вызвать метод Start() у объекта thread.

            CheckThread();
            Console.ReadLine();

            /* После этого поток начинает выполняться, и выполняется в пределах метожа ThreadMothod(). По сути, это будет процедурой Main для нашего потока.
             * Когда метод ThreadMothod() завершается, то и поток тоже становится завершённым.
             * При этом наши потоки блокируют работу процесса, т.е пока все потоки не завершатся, наше приложение также не завершится. Это происходит потому,
             * что все потоки, которые мы создаём таким образом, являются главными. Номера потоков - это нумерация потоков в пределах процесса.*/
        }
         
        private static void ThreadMethod()
        {
            CheckThread();
        }

        private static void CheckThread()
        {
            var thread = Thread.CurrentThread;
            Console.WriteLine("id:{0} - {1}", thread.ManagedThreadId, thread.Name);
        }




#elif Многопоточность_и_отладка
        /* Задача отладки многопоточных приложений может оказаться сложной. Это становится онятным, если добавить пару циклов, одни из которых
         * находится внутри созданного нами потока. Кроме того, ошибки, который могут произойти в результате доступа двух потоков к одному ресурсу,
         * в режиме пошаговой отладки перехватить невозможно. Помочь может панель "Место отлалдки", "Поток", в которой можно переключаться между
         * потоками в режиме отладки.*/

        /* Когда мы создаём объект Thread, он создаётся изгачально как равноправный в пределах всего нашего приложения. //Т.е. пока все равноправные потоки
         * не завершатся, наш процесс не выгрузится из памяти. Однако, можно назначить поток фоновым, т.е. понизить его  в правах. И при этом операционная система сможет выгрузить процесс
         * даже если в нём есть фоновые потоки. Для этого понадобится устанговить свойство IsBackground = true. В этом случае поток перестанет
         * блокировать выгрузку нашего процесса. Т.е. если есть задача создать какой-то поток, который наблюдает за чем-то, например, watchdog, 
         * т.е. поток, который следит за тем, чтобы другой поток не завис, либо поток логирования, который также может в непрерывном цикле обрабатывать
         * какую-то коллекцию, и при обнаружении новых объектов в этой коллекции, записывать их в журнал, то етому потоку необходимо выставить свойство
         * IsBackground = true, и после этого он не будет нам мешаться:*/

        /* Также можно выставить приоритет потока. В среде .Net предоставляется 5 вариантов приоритетов. В операционной системе существует 24 приоритета.
         * При этом приоритет потоков учитывается на уровне всей операпционной системы, т.е. потоки конкурируют за время процессора в соответствии
         * со своим приоритетом не только внутри нашего приложения, но и с процессами других приложений. Если у нас поток выполняет какую-то
         * короткую операцию, и должен сделать это быстро, то нужно задать ему повышенный приоритет, наприме, AboveNormal. Если это поток, действия 
         * которого не важны и должны ваыполняться во вторую очередь, то этому потоку имеет смысл занизить приоритет. Но работа с приоритетами это
         * такая вещь, к которой можно прийти, если все другие инструменты уже исчерпаны, либо если есть понимание, что мы делаем. В этом случае
         * приоритеты помогут.*/

        static void Main(string[] args)
        {
            Thread.CurrentThread.Name = "Main thread";

            var clock_thread = new Thread(ThreadMethod);
            clock_thread.Name = "Other thread";
            clock_thread.IsBackground = true;                             // В этом случае поток перестанет блокировать выгрузку нашего процесса.
            clock_thread.Priority = ThreadPriority.AboveNormal;

            clock_thread.Start();

            CheckThread();

            for (var i = 0; i < 100; i++)
                Console.WriteLine(i);

            Console.ReadLine();
        }

        private static void ThreadMethod()
        {
            CheckThread();

            while (true)
            {
                Thread.Sleep(100);
                Console.Title = DateTime.Now.ToString();
            }
        }

        private static void CheckThread()
        {
            var thread = Thread.CurrentThread;
            Console.WriteLine("id:{0} - {1}", thread.ManagedThreadId, thread.Name);
        }




#elif Передача_информации_в_поток
        /* В классе Thread можно передать информацию внутрь потока при его старте. Для этого можно воспользоваться перегрузкой конструктора,
         * которая принимает другой тип делегата. Т.е. делегат может принимать объект с качестве параметра. Параметр при этом нужно передать
         * методу Start(). Дале в методе потока нужно приводить его в нужному типу. Этот механизм появился на заре создания всей системы
         * работы с потоками, и он не совсем удобен и не совсем безопасен, потому что приходится использовать приведение типов. Кмроме того
         * так можно передать только 1 параметр:*/
        static void Main(string[] args)
        {
            var thread = new Thread(ThreadMethod);

            thread.Start(42);                                       // Параметр передаётся через метод Start().

            // Допустим, что у нас есть набор данных, и нам эти данные нужно передать в метод PrintMethod потока:
            var count = 5;
            var msg = "HelloWolrd!";
            var timeout = 150;

            /* Создаём объект Thread, не записывая его не в какие переменные (его сборщик мусора не удалит, пока поток не завершится).
             * Используем внутри лямба-выражение, с помощью которого вызываем метод: */
            new Thread(() => PrintMethod(msg, count, timeout)) { IsBackground = true }.Start();

            Console.ReadLine();
        }

        private static void ThreadMethod(object parametr)
        {
            var value = (int)parametr;
            Console.WriteLine(value);
            Console.WriteLine(parametr);                            // В этой версии .Net можно не приводить тип.
        }

        private static void PrintMethod(string Massage, int Count, int Timeout)
        {
            for (var i = 0; i < Count; i++)
            {
                Console.WriteLine(Massage);
                Thread.Sleep(Timeout);
                //Thread.SpinWait(1000);
                Console.WriteLine(i);
            }
        }




#elif Взаимодействие_потоков
        /* Когда в нашем приложении существуют множество потоков, то возникает ряд проблем, связанных с их взаимодействием между собой, особенно, если потоки
         * взаимодействуют с каким-то ресурсом, целостность которого является проблемой в многопоточном приложении. Каждый поток выполняет набор инструкций,
         * причём набор инструкций, который мы прописываем, не является атомарным, т.е. каждая инструкция внутри себя может содержать инструкции более низкого
         * уровня. Например, часто можно встретить работу со списком в потоках, когда у нас есть список значений, и 10 потоков, которые записывают данные в
         * этот список. При этом, обращение каждого потока на добавдление элемента внутрь списка пораждает внутри списка ряд операций, которые он должен
         * выполнить, и если один поток начал процесс добавления элемента в список и был прерван в процессе, и в это время второй поток точно также выполняет
         * некоторые действия над этим списком, то можно получить очень неожиданные результаты: */

        static void Main(string[] args)
        {
            var values = new List<int>();
            var threads = new Thread[10];                           // Создадим 10 потоков, каждый из которых будет записывать в списов свой идентификатор.

            //for (var i = 0; i < threads.Length; i++)
            //    threads[i] = new Thread(() =>
            //    {
            //        for (var j = 0; j < 10; j++)                    // Запись идентификатора каждого потока будет осуществляться 10 раз.
            //        {                        
            //            values.Add(Thread.CurrentThread.ManagedThreadId); // При добавлении данных в список иногда (не всегда!) происходит ошибка из-за
            //                                                              // одновременного обращения к нему нескольких потоков. Один из потоков был прерван,
            //                                                              // пока список занимался изменением размера своего внутреннего массива.
            //        }
            //    });

            /* В этом цикле иногда происходит ошибка, из-за одновременного обращения к списку нескольких потоков.
             * Ресурсы, к которым обращаются множество потоков, и могут при этом разрушить их внутренне состояние (если будут работать с ними не согласованно)
             * называются "Критической секцией". Чтобы избавиться от ошибки можно использовать специальные коллекции, которые защищены от многопоточного доступа.
             * Они находятся в пространстве имён System.Collections.Concurent.Это ConcurentBag, либо ConcurentQueue. Также есть ConcurentDictionary.
             * Если не использовать данные коллекции, то критическую секцию нужно блокировать. Причём блокировать нужно именно в момент, когда работа
             * происходит внутри критической секции. Критической секция у нас является список values.Его и надо заблокировать.
             * К списку мы обращаемся внутри цикла. Можно зоблокировать цикл, но тогда исчезнет асинхронность, т.е.приложение останется многопоточным, но
             * все потоки будут выполняться последовательно, а не параллельно.Для этого воспользуемся специальным синтаксическим сахаром - оператором lock,
             * внутри которого нужно указать объект ссылочного типа, на котором будет выполняться блокировка.Но часто можно видеть создание специального объекта
             * (object lock_object) для блокировки:*/

            object lock_object = new object();
            for (var i = 0; i < threads.Length; i++)
                threads[i] = new Thread(() =>
                {
                    for (var j = 0; j < 10; j++)
                    {
                        //lock (values)
                        lock (lock_object)
                            values.Add(Thread.CurrentThread.ManagedThreadId);
                    }
                });

            foreach (var thread in threads)                         // Пробежимся по всем потокам и запустим их на выполнение.
                thread.Start();

            Console.WriteLine(string.Join(",", values));

            Console.ReadLine();

            /* Не всегда можно использовать оператор lock. Если работать в асинхронном приложении с использованием TLP (async/await), и у нас есть асинхронный
             * метод, то внутри этого метода конструкцию lock использовать не получится. Кроме того, существуют такие сложные сценарии многопоточной обработки,
             * когда заблокировать критическую секцию надо в одном потоке, а разблокировать надо в другом потоке, и здесь конструкция lock тоже не поможет.
             * В этом случае надо понимать, как она устроена. Устроеан она также как и цикл foreach или конструкция using. Она разворачивается компилятором
             * в набор директив на C#. Выглядит это следующим образом. Внутри лежит класс Monitor. Именно он осуществляет блокировку критической секции.
             * У него есть метод Enter() - вход в критическую секцию. При этом метод Enter() блокирует процесс выполнения потока до тех пор, пока
             * критический объект lock_object не будет разблокирован в другом месте. Т.е. до тех пор, пока потоки занимаются добавлением данных в список,
             * главный поток будет заблокирован и продолжит выполнение после того, как очередной из потоков выйдет из критической секции.*/

            Monitor.Enter(lock_object);                             // Напчинается выполнение оператора lock с блокировки.
            try                                                     // try освобождает критическую секцию даже в том случае, если у нас при работе внутри неё
                                                                    // происходит какая-то ошибка (исключение). В блоке try находится критическая секция.
            {

            }
            finally                                                 // В блоке finaly происходит выход из блокировки.
            {
                Monitor.Exit(lock_object);
            }

            /* Таким образом можно самостоятельно имитировать работу оператора lock, используя  Monitor.Enter и Monitor.Exit используя их в разныч частях
             * программы, в разных потоках или в другой части асинхронного метода, но при этом желательно использовать конструкцию try/finaly, чтобы
             * не образовать мёртвых блокировок. Таким образом при взаимодействии с потоками придётся использовать ряд примитивов, причём очень низкоуровневых,
             * и большинство их них находятся даже не на уровне платформы .Net, а лежат внутри ядра операционной системы. Т.е. это очень глубокие механизмы,
             * с которыми взаимодействует платформа .Net, предоставляя свой уровень абстракции. Методы Enter и Exit внутри себя порождают ряд более сложных
             * операций.*/
        }




#elif Мягкая_остановка_потока
        private static bool _ThreadUpdate = true;                   // Используем этот флаг в цикле while в методе ThreadMethod().

        /* Если из другого потока сбросить флаг _ThreadUndate, то поток часов вывалится из этого цикла и завершится. Это называется
         * Мягкая остановка, и в ряде случаев поток, который мы пытаемся остановить таким образом, должен быть подвижным, и постоянно проверять этот флаг
         * Если в потоке выполняется какая-то длительная операция, которая сама по себе может повиснуть, то этот вариант работать на будет, или будет
         * не эффективным:*/

        static void Main(string[] args)
        {
            var clock_thread = new Thread(ThreadMethod);
            clock_thread.Start();

            for (var i = 0; i < 100; i++)
                Console.WriteLine(i);

            Console.ReadLine();
        }

        private static void ThreadMethod()
        {
            while (_ThreadUpdate)
            {
                Thread.Sleep(100);
                Console.Title = DateTime.Now.ToString();
            }
        }        




#elif Прямая_или_жёсткая_остановка_потока
        // ДАННЫХ МЕТОДОВ СТАРАЮТСЯ ИЗБЕГАТЬ В ПОЛЬЗУ МЯГКОЙ ОСТАНОВКИ (В СВОЮ ОЧЕРЕДЬ, РАБОТОЙ С ПОТОКАМИ ТАКЖЕ СЛЕДУЕТ ИЗБЕГАТЬ В ПОЛЬЗУ РАБОТЫ С ЗАДАЧАМИ).
        /* См. метод ThreadMethod(). Это не безопасный вариант. Есть возможность синхронизироваться с потоком.
         * Допустим, что в приложении одновременно выполняется два потока команд. В ряде сценариев может потребоваться, чтобы один поток дождался, пока
         * другой поток не завершится, и после этого продолжил свою работу. В этом случае нужно обладать ссылкой на объект потока, который нужно дождаться,
         * и у него есть метод Join, который позволяет остановитьтекущий главный поток до того времени, пока вторичный поток не быдет завершён.
         * При этом можно ожидать его до бесконечности, либо можно передать в качестве параметра численное значение таймаута в милисекундах, которое
         * мы будем ждать. При этом метод Join нам вернёт либо истину (удалось синхронизироваться), либо ложь (не удалось).*/

        static void Main(string[] args)
        {
            var clock_thread = new Thread(ThreadMethod);
            clock_thread.Start();

            /* Часто можно увидеть следующую конструкцию(до появления TPL). Если нам не удалось синхронизироваться за таймаут 100 мс (причём этот
             * таймаут должен быть равет таймауту внутри потока, либо превышать его в 2 раза, например, чтобы гарантировано поток имел возможность
             * остановиться):*/

            if (clock_thread.Join(100)) /*или f(!clock_thread.Join(100))*/
            {
                /* Если внктри потока в процессе остановки что-то пойдёт нитак, то его можно "прибить". Сделать это можно двумя способами: это вызвать метод
                 * Abort(), или вызвать метод Interrupt().*/

                //clock_thread.Abort();

                /* Abort() прерывает поток в любой точке процесса его выполнения. Это может пагубно сказаться на целостности объектов, Сейчас этот
                 * метод запрещён(?) внутри .Net. На любом этапе взаимодействия с объектом поток может быть прерван путём исключения ThreadAbortedAxception().
                 * Напрмер, мы читаем файл, и испл,олльзуем объект для чтения этого файла, причём этоти объект может использоваться несколькими потоками.
                 * Когда топок прерывается при чтении файла через объект, но объект чтения файла будет находиться в несинхронизтрованном состоянии,
                 * т.е. часть переменных внутри объекта будет установлена, а часть не будет, и таким образом наруцшается инкапсуляция этого объекта,
                 * что пагубно скажется на других потокахЮ которые будут работать с этим объектом.*/

                clock_thread.Interrupt();

                /* Interrupt() не сказывается пагубно на целостности объектов. Прерывает поток и выдаёт исключение ThreadAbortedAxception() либо
                 * внутри метода Sleep, либо внутри метода Spinwait(). Таким образом нарушить целостность объектов он не сможет.*/
            }
        }

        private static void ThreadMethod()
        {
            while (true)
            {
                Thread.Sleep(100);
                Console.Title = DateTime.Now.ToString();
            }
        }



        
#elif Базовые_примитивы_блокировки_и_взаимной_синхронизации_потоков
        static void Main(string[] args)
        {        
            System.Threading.Mutex mutex = new Mutex();

            /* Mutex - именованный объект уровня ядра операционной системы. Когда мы создаём Mutex, то он создаётся на уровне всеё операционной системы.
             * Если у нас есть несколько приложений, то они получат этот объект, но при этом тот, кто создаст его не первым, будет уведомлён о том, что
             * он его создал не первым. Через Mutex можно осуществлять синхронизацию между несколькими процессами.*/

            System.Threading.Semaphore semaphore = new Semaphore(0, 10);    // Семафор на 10 входов.

            /* Semaphore - это объект, который позволяет блокировать критическую секцию также через ядро операционной системы. Он позволяет ограничить
             * количество входов внутрь себя. Это самый низкий уровень синхронизации*/

            //semaphore.WaitOne();                                        // Каждый поток, который обращается к семафору, может пройти через него методом WaitOne(),
            /* Действия в критической секции*/                          // выполнить некоторые действия в критической секции,
            //semaphore.Release();                                        // и дальше выйти из семафора.

            /* В критическую секция сможет попасть всего 10 потоков. 11-й поток застрянет на методе WaitOne(), пока один их 10-ти потоков? которые 
             * работали с критической секцией не вызовет метод Release у семафора. Использовать семафор можно для ограничения нагрузки на сервер
             * (например, органичение количества подключений).*/

            // Объекты синхронизации более высокого уровня. Работают одинакого:
            ManualResetEvent manualResetEvent = new ManualResetEvent(false);    // false - несигнальное, сброшенное состояние.
            AutoResetEvent autoResetEvent = new AutoResetEvent(false);

            //EventWaitHandle thread_guidance = manualResetEvent;     // Объект синхронизации потоков. EventWaitHandle - базовый класс для Manual- и AutoResetEvent

            EventWaitHandle thread_guidance = autoResetEvent;

            var test_threads = new Thread[10];
            for (int i = 0; i < test_threads.Length; i++)
            {
                var local_i = i;
                test_threads[i] = new Thread(() =>
                {
                    Console.WriteLine("Поток id:{0} - стартовал", Thread.CurrentThread.ManagedThreadId);

                    thread_guidance.WaitOne();                      // Различия между Manual- и AutoResetEvent заключается в том, что при проходе через метод
                                                                    // WaitOne() состояние флага у ManualResetEvent не сбрасывается, а у AutoResetEvent
                                                                    // сбрасывается. Текущий поток застрянет на методе WaitOne(), и будет ждать, пока
                                                                    // кто-то другой не возьмёт этот объект (thread_guidance) и не вызовет у него метод Set(),
                                                                    // переведя т.о. thread_guidance в сигнальное состояние. После этого поток, который был
                                                                    // на методе WaitOne() сможет продолжить свою работу.

                    Console.WriteLine("Value{0}", local_i);
                    Console.WriteLine("Поток id:{0} - завершился", Thread.CurrentThread.ManagedThreadId);
                    //thread_guidance.Set();
                });
                test_threads[i].Start();
            }

            Console.WriteLine("Готов к запуску потоков");

            Console.ReadLine();

            thread_guidance.Set();

            /* Если thread_guidance = manualResetEvent, то после нажатия Enter, в методе thread_guidance.Set() флаг переключится в состояние "установлено",
             * и все потоки смогут выполниться (завершится), т.е. проскочить через метод WaitOne().
             * Если thread_guidance = autoResetEvent, то после нажатия Enter первый поток, который проскочит через метод WaitOne(), сбросят состояние
             * объекта thread_guidance, и остальные потоки не смогут выполниться. Они будут ждать следующей установки метода Set(). Для того, чтобы
             * пропустить очередной поток, потребуется снова выполнить метод Set()*/

            // Примеры использования:

            /* Нужно написать модульный тест, где надо проверить, как будет какой-то объект работать в параллельно выполняющихся потоках. Мы готовим
             * объект, запускаем сразу несколько потоков, которые будут с этим объектом работать, и создаём объект manualResetEvent. После этого в каждом
             * потоке приостанавливаем его работу методом WaitOne(), а после него выставляем логику, которую нужно выполнить сразу параллельно в нескольких
             * потоках, и запускем все потоки одновременно методот Set(). Все потоки практически одновременно проваливаются в блок тестирования, и
             * выполняются одновременно на том объекте, который надо проверить.*/

            /* Эти методы можно увидеть где-то в низкоуровневых инструментах, например, в TPL, в расширениях, во всяких менеджерах задач они также
             * фигурируют при остановке/запуске потоков, которые обрабатывают какую-любо информацию. Так есть сценарий обработки данных, когда мы запускаем
             * поток, который непрерывно следит за каким-то списком, и если в этом списке есть задачи, то он извлекает одну задачу из этого списка и
             * начинает её выполнять. При этом может быть второй поток, который его грузит этими самыми задачами. При этом, если в списке ничего нет,
             * то поток сам себе автоматически может ставить блокировку спомощью объекта manualResetEvent (сбрасывать его состояние: 
             * thread_guidance.Reset())? а второй поток, который загружает список новой задачей, после того, как он добавитс в список задачу,
             * он может установить флаг thread_guidance.Set(), и второй поток возобновится и начнёт её выпонять.*/

            /*Все эти сценарии сейчас можно реализовать с помощью TPL, но с накладными расходами.*/
        }




#elif Защита_метода_от_многопоточности
        /* Чтобы защитить метод, сделать его атомарным для выпотнениянескольких потоков, нужно добавить атрибут [MethodImpl]. У этого
         * атрибута есть много флагов. При добавлении флага (MethodImplOptions.Synchronized), вокруг метода компилятором создаётся
         * конструкция с lock-ом, и блокировка выполняется на объекте, внутри которого описан этот метод. Т.е. если это объект ссылочного типа, 
         * то внутрь директивы lock попадает ссылка на сам объект. Если это статический метод, то создаётся статическое поле (возможно. 
         * учитель не помнит):*/

        [MethodImpl(MethodImplOptions.Synchronized)]
        private static void ThreadtMethod()
        {
        }




#elif Запуск_CV19Web_WebServer
        /* Для возможности запуска CV19.Web/WebServer из консольно тестового проекта, предварительно нужно в в папке Tests/CV19Console/Зависимости
         * добавить ссылку на проект у поставить галочку напротив CV19Web*/

        static void Main(string[] args)
        {
            WebServerTest.Run();
            return;
        }
#endif
    }
}
