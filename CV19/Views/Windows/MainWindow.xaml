<!--Директивы "xmlns=", "mlns:x=", "xmlns:d=", "xmlns:mc=", которые указываются в начале разметки - это подключение пространств имён WPF (это некая строка, оформленная в виде интернет-адреса).
    Каждая из этих строк подключаем много пространств имён. Главное пространство имён подключается строчкой "xmlns=". Оно служит пространством имён для всей xaml-разметки.
    "mlns:x=", "xmlns:d=", "xmlns:mc=" - дополнительные пространства имён. x, d, mc - псевдонимы пространств имён, которые в последствии могут использоваться в самой разметке.
    Можно подключать дополнительные пространства имён спомощью директивы "clr-namespace:".
    Добавляем пространство имём xmlns:vm="clr-namespace:CV19.ViewModels", после чего внутри свойства <Window.DataContext></Window.DataContext> мы можем создать ViewModel вручную.
    <vm:MainWindowViewModel/> - указываеам, что теперь контекстом данных является объект класса MainWindowViewModel, который будет здесь создан. И теперь об этом знает дизайнер-студия,
    и будет делать подсказки при использовании этого класса внутри разметки.
    Вместо Title="MainWindow" напишем Title={}. {} означают, что внутри будут находиться не обычные значения, а расширение разметки.
    Расширение Binding - часть разметки, средство, которое устанавливает привязку к данным между свойствами двух объектов или одного объекта.
    Если есть затруднения с тем, что нужно написать, то можно написать параметр Path=, и среда разоработки выдаст перечень того, к чему можно привязаться.
    Первый параметр после Binding указывает имя свойство, к которому можно привязаться.-->
<Window x:Class="CV19.MainWindow"        
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        xmlns:fa="http://schemas.fontawesome.com/icons/"
        xmlns:cmd="clr-namespace:CV19.Infrastructure.Commands"
        xmlns:decanat="clr-namespace:CV19.Models.Decanat"
        xmlns:vm="clr-namespace:CV19.ViewModels"
        xmlns:local="clr-namespace:CV19"
        xmlns:oxy="http://oxyplot.org/wpf"
        Title="{Binding Path=Title}"
        Height="450" Width="800">
    <!--На уровне окна можно добавить команду на закрытие:-->
    <Window.InputBindings>
        <KeyBinding Modifiers="Ctrl" Key="Q" Command="{Binding CloseApplicationCommand}"/>
    </Window.InputBindings>
    <!--Внутри любого визуального элемента есть единое свойство DataContext, которое иерархически насдедуется внутри дерева интерфейса.
    То есть, если определить DataContext на уровне окна, то все вложенные элементы получают значение этого самого DataContextа.
    Если переопределить DataContext где-то уровнем ниже, то всё, что находится ниже по дереву интерфейса, изменит свой контекст данных.
    Можно написать DataContext="" после Title="MainWindow" Height="450" Width="800", а можно развернуть так: <Window.DataContext></Window.DataContext>-->
    <!--Каждый тег <...> - это объект, который рождается в момент загрузки окна.-->
    <Window.DataContext>
        <vm:MainWindowViewModel/>
    </Window.DataContext>
    <!--В словать ресурсов можно что-то поместить, только указав ключ. Сделаем ключ такой же, как и класс: "CloseApplicationCommand"-->
    <Window.Resources>
        <cmd:CloseApplicationCommand x:Key="CloseApplicationCommand"/>
    </Window.Resources>
    <DockPanel>
        <Menu DockPanel.Dock="Top">
            <MenuItem Header="Файл">
                <!--Вызов команды из ViewModel:-->
                <!--<MenuItem Header="Выход" Command="{Binding CloseApplicationCommand}"/>-->
                <!--Альтернативный вариант написания команды (на примере отдельной команды из Command):-->

                <!--Команда "по месту". Здесь в разметку Parser-xaml создаст объект и вставит его в свойство Command. Если какая-то много где используется (например, в других окнах или в шаблонах),
                    То такой подход быдет слишком расточителен для памяти, особенно, если используется DataGrid с множеством строк, внутрь каждой строки будет помещён визуальный объект
                    и внутрь этого объекта помещена команда. Во первых они будут очень долго создаваться, а во вторых они съедят много памяти-->
                <!--<MenuItem Header="Выход">-->
                <!--<MenuItem.Command>
                        <cmd:CloseApplicationCommand/>
                    </MenuItem.Command>-->
                <!--Поэтому (да и вообще всегда), такие команды имеет смысл вынести в отдельные ресурсы, которые будут доступны той разметке, в которой они нужны.
                    То есть если какая-то команда используется исключительно в пределах окна, то имеет смысл в пределах окна создать область ресурсов и туда поместить эту самую команду,
                    которая в последствии внутри всего окна будет использоваться.
                    Если эта команда уровня всего приложения, и она используется в нескольких окнах, тогда имеет смысл завестя словарь ресурсов, и подключить его на уровне всего приложения
                    в файле App.xaml нутри "Application.Resources", и тогда эту команду можно будет, как ресурс, подключить в любом месте разметки, и она небудет сжирать память каждый раз.
                    То есть она лишь в одном месте будет объявлена, и её можно будет оттуда использовать.
                    Для уровня данного окна, нужно создать ресурс этого окна (см. "Window.Resources" вверху) (ресурсы можно объявить на любом уровне разметки), и после этого используем
                    команду, как ресурс:-->
                <MenuItem Header="Выход" Command="{StaticResource CloseApplicationCommand}"/>
            </MenuItem>
            <MenuItem Header="Помощь">
                <MenuItem Header="О программе"/>
            </MenuItem>
            <MenuItem Command="{Binding ChangeTabIndexCommand}" CommandParameter="-1">
                <MenuItem.Header>
                    <fa:ImageAwesome Height="12" Icon="Regular_ArrowAltCircleLeft"/>
                </MenuItem.Header>
            </MenuItem>
            <MenuItem Command="{Binding ChangeTabIndexCommand}" CommandParameter="+1">
                <MenuItem.Header>
                    <fa:ImageAwesome Height="12" Icon="Regular_ArrowAltCircleRight"/>
                </MenuItem.Header>
            </MenuItem>            
        </Menu>
        <StatusBar DockPanel.Dock="Bottom">
            <StatusBarItem MinWidth="150" MaxWidth="350">
                <TextBlock Text="{Binding Status}"/>
            </StatusBarItem>
            <StatusBarItem>
                <ProgressBar Width="120" Height="14" Value="30"/>
            </StatusBarItem>
            <StatusBarItem Content="{Binding SelectedPageIndex}"/>
            <!--Чтобы всё правильно работало и индексы не выходили за количество вкладок, нужно кое-чего добавить (информацию о количестве вкладок).-->
        </StatusBar>

        <!--Модель-представления ничего не должна знать о визуальных элементах, но при этом можно ввести внутрь модели-представления индекс активной вкладки. Для этого возьмём свойство TabControl SelectedIndex
         и свяжем его со свойством SelectedPageIndex во ViewMosel-->
        <TabControl SelectedIndex="{Binding SelectedPageIndex}">
            <!--<TabItem Header="Вкладка 1">-->
            <!--Свойство Header принимает тип object. Это значит, что его можно развернуть следующим образом и внутри создать разметку:-->
            <TabItem Header="Студенты">
                <!--У нас подключена View-Model, и по идее там должны быть студенты. Можно заглянуть и посмотреть, чтобы удостовериться, есть там что или нет:-->
                <!--<TextBlock Text="{Binding Groups}"/>                                    --><!--Удостоверимся, что есть объект Collection-->
                <!--<TextBlock Text="{Binding Groups.Count}"/>                              --><!--Количество групп-->
                <!--<TextBlock Text="{Binding Groups[0].Name}"/>                            --><!--Название первой группы-->
                <!--TextBlock Text="{Binding Groups[1].Students.Count}"/>                --><!--Количество студентов во второй группе-->
                <!--<TextBlock Text="{Binding Groups[0].Students[0].Name}"/>                    --><!--Имя первого студента первой группы-->
                <Grid>
                    <Grid.ColumnDefinitions>
                        <!--<ColumnDefinition Width="3*"/>
                        <ColumnDefinition Width="7*"/>-->
                        <ColumnDefinition Width="250"/>
                        <ColumnDefinition/>
                    </Grid.ColumnDefinitions>
                    <GroupBox Grid.Column="0" Header="Группы">
                        <!--ListBox, когда не знает, что делать с объектом, вызывает у него метод ToString. Поэтому нужно либо переопределить метод ToString в классе.
                        Либо можно сделать так: У списочных элементов, таких как ComboBox, ListBox, ListView и пр. есть два свойства: DisplayMemberPath и SelectedValuePath.
                        Поэтому можно установить DisplayMemberPath в свойство Name. В этом случае у нас отобразится имя группы:-->
                        <ListBox ItemsSource="{Binding Groups}" SelectedIndex="0"
                                 DisplayMemberPath="Name"
                                 SelectedItem="{Binding SelectedGroup}"/>
                    </GroupBox>
                    <GroupBox Grid.Column="1" Header="{Binding SelectedGroup.Name, FallbackValue='Студенты', TargetNullValue='Группа не выбрана'}">
                        <!--Возьмём для разнообразия DataGrid - очень мощный элемент для визуализации данных в табличном виде. Можно кастомизировать отдельные ячейки.
                        Кроме того, он очень быстрый, и предназначен для демонстрации огромных массивов данных (при правильной его подготевке).
                        Запретим DataGrid самостоятельно создавать дополнительные колонки: AutoGenerateColumns="False".
                        После этого нужно указать, какие именно колонки должны отображаться: DataGrid.Columns. По умолчанию достцупны 5 типов колонок, которые можно использовать.
                        Из них DataGridTextColumn самый главный тип. Он универсальный, и позволяет отображать любые данные в текстовом представлении (это могут быть и численные данные и дата).
                        Не дадим пользователю редактировать данные: IsReadOnly="True".
                        Для удаления горихонтальный хилий: HorizontalGridLinesBrush="{x:Null}" или GridLinesVisibility="Vertical"-->
                        <DataGrid ItemsSource="{Binding SelectedGroup.Students}"
                                  AutoGenerateColumns="False"
                                  IsReadOnly="True"
                                  GridLinesVisibility="Vertical"
                                  VerticalGridLinesBrush="DarkGray"
                                  AlternatingRowBackground="LightGray">
                            <!--HorizontalGridLinesBrush="{x:Null}"-->
                            <DataGrid.Columns>
                                <!--По умолчанию привязка производится к контексту данных. Контекстом данных каждой строки является объект Student, поэтому привязка производится к нему.
                                При этом, каждый Binding можно отформатировать отдено. Отформатируем дату рождения. Чтобы видеть, как меняется форматирование, временно для отладки в строке
                                <ListBox ItemsSource="{Binding Groups}" выставим SelectedIndex="0". (На сайте CodeProject есть статья по кастомизации DataGrid, включая вставку картинок, измение цвета и т.д.)-->
                                <DataGridTextColumn Header="Фамилия" Binding="{Binding Surename}" Width="Auto"/>
                                <!--Width="Auto" - подстройка ширины под контент. C Framework не стабильно работает-->
                                <DataGridTextColumn Header="Имя" Binding="{Binding Name}"/>
                                <DataGridTextColumn Header="Отчество"  Binding="{Binding Patronymic}"/>
                                <DataGridTextColumn Header="Рейтинг" Binding="{Binding Rating}"/>
                                <!--<DataGridTextColumn Header="Дата рождения" Binding="{Binding Birthday, StringFormat=dd.MM.yyy}"/>-->
                                <!--DataGridTemplateColumn позволяет сконфигурировать колонки так, как нам надо. Внутри установим свойство CellTemplate.-->
                                <DataGridTemplateColumn Header="Дата рождения">
                                    <DataGridTemplateColumn.CellTemplate>
                                        <!--Многие визуальные элементы позволяют демонстрировать своё содержимое разным специфическим образом.
                                        Все списочные элементы (ItemsControl - это все списочные элементы представления, такие как список групп;
                                        TabItems - это тоже списочный элемент управления) обладают свойством ItemsTemplate, которое позволяет указать шаблон визуализации данных. 
                                        А также есть ContentControl - это все элементы, которые позволяют отображать некоторое содержимое. Нопример, кнопка является элементом ContentControl.
                                        У таких элементов есть свойство ContentTemplate. В любом случае эти свойства принимают в качестве значения объект скласса DataTemplate. То есть это шаблон визуализации данных,
                                        внутри которого нужно описать разметку, которая будет применена для того, чтобы нарисовать этот элемент на экране на основе тех данных, которые мы хотим отображать.
                                        Для DataTemplate жаелательно указывать тип элемента данных с помощью свойства DataType. Если этого не сделать, то студия не будет подсказывать набор свойств самого элемента внутри
                                        этого шаблона (к) которым можно выполнять привязки к данным. Кроме указания типа элементов нужно указать пространство имён: xmlns:decanat="clr-namespace:CV19.Models.Decanat".
                                        Таким образом мы конфигурируем DataTemplate на работу с типом данных Student.-->
                                        <DataTemplate DataType="decanat:Student">
                                            <!--Строим разметку того, как элемент должен представляться на экране. Элемент DatePicker предназначен для отображения даты в выпадающем списке.-->
                                            <DatePicker SelectedDate="{Binding Birthday}"/>
                                        </DataTemplate>
                                    </DataGridTemplateColumn.CellTemplate>
                                </DataGridTemplateColumn>
                                <!--Добавим привязку к группе. Сейчас мы находимся в каждой строке (не в колонке) нашей таблицы. Строка находится в контейнере строк DataGrid-а,
                                котортый наодится в саммом DataGrid-е. Нам надо подняться по этой иерархии вверх до уровня DataGrid. Проблема в том, что в кажой строке установлено свойство DataContext,
                                а нам необходим DataContext в DataGrid. Будем использовать относительный источник данных RelativeSource, устанавливаем требуемый тип AncestorType=DataGrid.
                                В этом случае мы будем подниматься вверх по дереву интерфейса до узла DataGrid, и в нём нас будет интересовать DataContext SelectedGroup.Name:-->
                                <!--<DataGridTextColumn Header="Группа" Binding="{Binding DataContext.SelectedGroup.Name, RelativeSource={RelativeSource AncestorType=DataGrid}}"/>-->
                                <DataGridTextColumn Header="Заметки" Binding="{Binding Description}" Width="*"/>
                            </DataGrid.Columns>
                        </DataGrid>
                    </GroupBox>
                </Grid>
            </TabItem>
            <!--<TabItem Header="{Binding TestDataPoints}"></TabItem>--> 
            <!--Если написано (Collection), значит там что-то есть...-->
            <!--<TabItem Header="{Binding TestDataPoints.Count}"></TabItem>-->
            <!--Будет показывать количество элементов.-->
            <!--<TabItem Header="{Binding TestDataPoints[400]}"></TabItem>-->
            <!--Так мы увидим, что это элементы типа DataPoint-->
            <!--<TabItem Header="{Binding TestDataPoints[400].XValue}"></TabItem>-->
            <!--Получим значение 400-сотой точки X-->
            <TabItem Header="График">
                <!--Предварительно вверху подключим пространство имён OxyPlot: xmlns:oxy="http://oxyplot.org/wpf"-->
                <oxy:Plot>
                    <oxy:Plot.Axes>
                        <oxy:LinearAxis Position="Left"/>
                        <oxy:LinearAxis Position="Bottom"/>
                    </oxy:Plot.Axes>
                    <oxy:LineSeries Color="Red"
                                    ItemsSource="{Binding TestDataPoints}"
                                    DataFieldX="XValue"
                                    DataFieldY="YValue"/>
                </oxy:Plot>


            </TabItem>
            <TabItem Header="Вкладка 2"></TabItem>
            <TabItem Header="Вкладка 3"></TabItem>
            <TabItem Header="Вкладка 4"></TabItem>
        </TabControl>
    </DockPanel>

</Window>
