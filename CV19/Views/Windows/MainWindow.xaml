<!--Директивы "xmlns=", "mlns:x=", "xmlns:d=", "xmlns:mc=", которые указываются в начале разметки - это подключение пространств имён WPF (это некая строка, оформленная в виде интернет-адреса).
    Каждая из этих строк подключаем много пространств имён. Главное пространство имён подключается строчкой "xmlns=". Оно служит пространством имён для всей xaml-разметки.
    "mlns:x=", "xmlns:d=", "xmlns:mc=" - дополнительные пространства имён. x, d, mc - псевдонимы пространств имён, которые в последствии могут использоваться в самой разметке.
    Можно подключать дополнительные пространства имён спомощью директивы "clr-namespace:".
    Добавляем пространство имём xmlns:vm="clr-namespace:CV19.ViewModels", после чего внутри свойства <Window.DataContext></Window.DataContext> мы можем создать ViewModel вручную.
    <vm:MainWindowViewModel/> - указываеам, что теперь контекстом данных является объект класса MainWindowViewModel, который будет здесь создан. И теперь об этом знает дизайнер-студия,
    и будет делать подсказки при использовании этого класса внутри разметки.
    Вместо Title="MainWindow" напишем Title={}. {} означают, что внутри будут находиться не обычные значения, а расширение разметки.
    Расширение Binding - часть разметки, средство, которое устанавливает привязку к данным между свойствами двух объектов или одного объекта.
    Если есть затруднения с тем, что нужно написать, то можно написать параметр Path=, и среда разоработки выдаст перечень того, к чему можно привязаться.
    Первый параметр после Binding указывает имя свойство, к которому можно привязаться.-->
<Window x:Class="CV19.MainWindow"        
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        xmlns:fa="http://schemas.fontawesome.com/icons/"
        xmlns:cmd="clr-namespace:CV19.Infrastructure.Commands"
        xmlns:decanat="clr-namespace:CV19.Models.Decanat"
        xmlns:vm="clr-namespace:CV19.ViewModels"
        xmlns:local="clr-namespace:CV19"
        xmlns:oxy="http://oxyplot.org/wpf"
        xmlns:sys="clr-namespace:System;assembly=System.Runtime"
        xmlns:cm="clr-namespace:System.ComponentModel;assembly=WindowsBase"
        Title="{Binding Path=Title}"
        Height="450" Width="800">
    <!--На уровне окна можно добавить команду на закрытие:-->
    <Window.InputBindings>
        <KeyBinding Modifiers="Ctrl" Key="Q" Command="{Binding CloseApplicationCommand}"/>
    </Window.InputBindings>
    <!--Внутри любого визуального элемента есть единое свойство DataContext, которое иерархически насдедуется внутри дерева интерфейса.
    То есть, если определить DataContext на уровне окна, то все вложенные элементы получают значение этого самого DataContextа.
    Если переопределить DataContext где-то уровнем ниже, то всё, что находится ниже по дереву интерфейса, изменит свой контекст данных.
    Можно написать DataContext="" после Title="MainWindow" Height="450" Width="800", а можно развернуть так: <Window.DataContext></Window.DataContext>-->
    <!--Каждый тег <...> - это объект, который рождается в момент загрузки окна.-->
    <Window.DataContext>
        <vm:MainWindowViewModel/>
    </Window.DataContext>
    <!--В словать ресурсов можно что-то поместить, только указав ключ. Сделаем ключ такой же, как и класс: "CloseApplicationCommand"-->
    <Window.Resources>
        <cmd:CloseApplicationCommand x:Key="CloseApplicationCommand"/>
        <!--Определение стиля всех кнопок на уровне всего окна:-->
        <!--<Style TargetType="Button">
            <Setter Property="Background" Value="White"/>
        </Style>-->
    </Window.Resources>
    <DockPanel>
        <Menu DockPanel.Dock="Top">
            <MenuItem Header="Файл">
                <!--Вызов команды из ViewModel:-->
                <!--<MenuItem Header="Выход" Command="{Binding CloseApplicationCommand}"/>-->
                <!--Альтернативный вариант написания команды (на примере отдельной команды из Command):-->

                <!--Команда "по месту". Здесь в разметку Parser-xaml создаст объект и вставит его в свойство Command. Если какая-то много где используется (например, в других окнах или в шаблонах),
                    То такой подход быдет слишком расточителен для памяти, особенно, если используется DataGrid с множеством строк, внутрь каждой строки будет помещён визуальный объект
                    и внутрь этого объекта помещена команда. Во первых они будут очень долго создаваться, а во вторых они съедят много памяти-->
                <!--<MenuItem Header="Выход">-->
                <!--<MenuItem.Command>
                        <cmd:CloseApplicationCommand/>
                    </MenuItem.Command>-->
                <!--Поэтому (да и вообще всегда), такие команды имеет смысл вынести в отдельные ресурсы, которые будут доступны той разметке, в которой они нужны.
                    То есть если какая-то команда используется исключительно в пределах окна, то имеет смысл в пределах окна создать область ресурсов и туда поместить эту самую команду,
                    которая в последствии внутри всего окна будет использоваться.
                    Если эта команда уровня всего приложения, и она используется в нескольких окнах, тогда имеет смысл завестя словарь ресурсов, и подключить его на уровне всего приложения
                    в файле App.xaml нутри "Application.Resources", и тогда эту команду можно будет, как ресурс, подключить в любом месте разметки, и она небудет сжирать память каждый раз.
                    То есть она лишь в одном месте будет объявлена, и её можно будет оттуда использовать.
                    Для уровня данного окна, нужно создать ресурс этого окна (см. "Window.Resources" вверху) (ресурсы можно объявить на любом уровне разметки), и после этого используем
                    команду, как ресурс:-->
                <MenuItem Header="Выход" Command="{StaticResource CloseApplicationCommand}"/>
            </MenuItem>
            <MenuItem Header="Помощь">
                <MenuItem Header="О программе"/>
            </MenuItem>
        </Menu>
        <StatusBar DockPanel.Dock="Bottom">
            <StatusBarItem MinWidth="150" MaxWidth="350">
                <TextBlock Text="{Binding Status}"/>
            </StatusBarItem>
            <StatusBarItem>
                <ProgressBar Width="120" Height="14" Value="30"/>
            </StatusBarItem>
            <StatusBarItem Content="{Binding SelectedPageIndex}"/>
            <!--Чтобы всё правильно работало и индексы не выходили за количество вкладок, нужно кое-чего добавить (информацию о количестве вкладок).-->
        </StatusBar>

        <!--Модель-представления ничего не должна знать о визуальных элементах, но при этом можно ввести внутрь модели-представления индекс активной вкладки. Для этого возьмём свойство TabControl SelectedIndex
         и свяжем его со свойством SelectedPageIndex во ViewMosel-->
        <TabControl SelectedIndex="{Binding SelectedPageIndex}">
            <!--Протестируем, как работает виртуализация:-->
            <TabItem Header="Тестирование виртуализации" Visibility="Collapsed">
                <Grid>
                    <!--Надо заметить, что дизайнер не предназначан для больших нагрузок по отображению огромного количества студентов.
                    Поэтому, чтобы он не сломался, добавим в приложение в App.xaml.cs специальное свойство, которое будет опрпделять, работаем ли мы в дизайнере, или запущен exe-файл.
                    Здесь же выполним отображение значения свойства (проверим, работает или нет). Текст привяжем к свойству Text="{Binding Source={x:Static local:App.IsDesignMode}}":-->
                    <!--<TextBlock Text="{Binding Source={x:Static local:App.IsDesignMode}}"/>-->
                    <!--После того, как свойство IsDesignMode влияет на количество групп, привяжем ListBox к нашему источнику:-->
                    <ListBox HorizontalAlignment="Left" Width="200" Margin="30"
                             ItemsSource="{Binding TestStudents}"
                             VirtualizingPanel.IsVirtualizing="True"
                             VirtualizingPanel.VirtualizationMode="Recycling"
                             VirtualizingPanel.IsContainerVirtualizable="True">
                        <!--Добавление виртуализации:-->
                        <ListBox.ItemsPanel>
                            <ItemsPanelTemplate>
                                <VirtualizingStackPanel/>
                            </ItemsPanelTemplate>
                        </ListBox.ItemsPanel>
                        <!--Отобразим списки 100000 студентов без виртуализации. Этот процесс занимает более 300 Мб памяти.-->
                        <ListBox.ItemContainerStyle>
                            <Style TargetType="ListBoxItem">
                                <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
                            </Style>
                        </ListBox.ItemContainerStyle>
                        <ListBox.ItemTemplate>
                            <DataTemplate DataType="decanat:Student">
                                <!--ToolTip="{Binding Name}" - всплывающая подсказка будет привязана к имени.-->
                                <Border BorderBrush="Blue" BorderThickness="1" CornerRadius="3"
                                        Padding="3">
                                    <!--Для большей загрузки памяти сделаем кэширование каждого визуального элемента:-->
                                    <Border.CacheMode>
                                        <BitmapCache EnableClearType="True" SnapsToDevicePixels="True" RenderAtScale="5"/>
                                    </Border.CacheMode>
                                    <StackPanel>
                                        <TextBlock Text="{Binding Surename}" ToolTip="{Binding Name}"/>
                                        <TextBlock Text="{Binding Name}" ToolTip="{Binding Name}"/>
                                        <TextBlock Text="{Binding Patronymic, TargetNullValue=--}" ToolTip="{Binding Name}"/>
                                    </StackPanel>
                                </Border>                                
                            </DataTemplate>
                        </ListBox.ItemTemplate>
                    </ListBox>
                </Grid>
            </TabItem>
            <!--<TabItem Header="Вкладка 1">-->
            <!--Свойство Header принимает тип object. Это значит, что его можно развернуть следующим образом и внутри создать разметку:-->
            <TabItem Header="Студенты">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="250"/>
                        <ColumnDefinition/>
                    </Grid.ColumnDefinitions>
                    <GroupBox Grid.Column="0" Header="Группы">
                        <DockPanel>
                            <!--В данный момент ListBox работает напрямую с коллекцией Groups. Изменим эту привязку. Для этого добавим в разметку объект CollectionViewSource:-->
                            <DockPanel.Resources>
                                <!--Объект CollectionViewSource предназначен для решения трёх задач: 1. задача фильтрации; 2. задача сортировки; 3. задача группировки данных в виде визуальных групп.
                                Это своего рода посредник между источником данных и визуальным представлением, который берёт на себя ответственность перечисленные задачи.-->
                                <CollectionViewSource x:Key="GroupsCollection"
                                                      Source="{Binding Groups}"
                                                      Filter="CollectionViewSource_Filter">
                                    <!--Сортировка:-->
                                    <CollectionViewSource.SortDescriptions>
                                        <cm:SortDescription PropertyName="Name" Direction="Descending"/>
                                    </CollectionViewSource.SortDescriptions>
                                    <!--Группировка (Не получается. Надо читать документацию. Если DataGrid поддерживает группировку автоматически, то d ListBox надо скорее выбирать свойство Groups
                                    у CollectionViewSource и в нём будут содержаться группы):-->
                                    <!--<CollectionViewSource.GroupDescriptions>-->
                                        <!--<PropertyGroupDescription PropertyName="Students.Count"/>-->
                                        <!--<PropertyGroupDescription PropertyName="Name"/>-->
                                    <!--</CollectionViewSource.GroupDescriptions>-->
                                </CollectionViewSource>
                            </DockPanel.Resources>
                            <!--Добавим сверху ещё одну Док-панель. По умолчанию она укладывает содержимое слева направа, что нам и нужно:-->
                            <DockPanel DockPanel.Dock="Top" Margin="0,3">
                                <!--<TextBlock Text="Фильтр:"/>-->
                                <fa:ImageAwesome Height="12" Icon="Solid_Search" Margin="3,0"/>
                                <!--Обработчик событий TextChanged="GroupNameFilterText_TextChanged" будет вызываться всякий раз, когда будет изменяться текст в поле фильтра выбора групп:-->
                                <TextBox Name="GroupNameFilterText" TextChanged="GroupNameFilterText_TextChanged"/>
                            </DockPanel>
                            <UniformGrid DockPanel.Dock="Bottom" Rows="1" Margin="0,3">
                                <Button Content="Добавить" Padding="0,7" Style="{StaticResource CheckButtonStyle}" Command="{Binding CreateGroupCommand}">
                                </Button>
                                <Button Content="Удалить" Padding="0,7" Style="{StaticResource RemoveButtonStyle}" Command="{Binding DeleteGroupCommand}" CommandParameter="{Binding SelectedGroup}"/>
                            </UniformGrid>
                            <!--Изменим эту привязку ListBox c {Binding Groups} на {Binding Source={StaticResource GroupsCollection}:-->
                            <!--<ListBox ItemsSource="{Binding Groups, Source={StaticResource GroupsCollection}}" SelectedIndex="0"-->
                            <ListBox ItemsSource="{Binding Source={StaticResource GroupsCollection}}" SelectedIndex="0"
                                     SelectedItem="{Binding SelectedGroup}"
                                     VirtualizingPanel.IsContainerVirtualizable="True"
                                     VirtualizingPanel.IsVirtualizing="True"
                                     VirtualizingPanel.VirtualizationMode="Recycling">
                                <!--Добавим виртуализацию к списку, чтобы обеспечить быстродействие для любых объёмов данных, если, например, групп будет несколько тысяч или миллионов,
                                чтобы визуальные элементы все сразу для них не создавались и не грузили память визуальной частью, которая в данных момент не нужна для отображения на экране
                                (Если ничего не делать, то для каждого элемента коллекции будет создан визуальный элемент, которых будет сидеть в памяти и ждать момента для появления,
                                что может не произойти никогда. Кроме того, будут созданы все обработчики событий и выполнена его логика, что может сильно замедлить приложение).
                                Поэтому необходимо изменить стандартный контейнер, с помощью которого списочный элемент отображает своё содержимое.
                                ListBox, DataGrid, Menu, TabItem, StatusBar – это всё списочные элементы управления. Они призваны для отображения списков каких-либо элементов данных.
                                У них у всех есть такое понятие, как панель, в которую кладутся их дочерние визуальные элементы. По умолчанию используется StackPanel.
                                У StatusBar (и возможно у меню) – это DockPanel. Можно использовать не просто StackPanel или DockPanel. Можно использовать UniformGrid.
                                В этом случае элементы уложатся по горизхонтали и вертикали. Можно использовать просто Grid. Можно использовать Convu,
                                и размещать элементы по координатам, в зависимости от их содержимого.
                                Изменим у списка его контейнер элементов. Укажем, какая ItemsPanel должна быть использована. Нам нужна панель, которая реализует возможности виртуализации.
                                Это VirtualizingStackPanel. Её идея заключается в том, что она рендерит только те элементы, которые видны на экране, а те, которые не видны, под них 
                                не создаются визуальные контейнеры.
                                Выше добавим несколько присоединённых свойств из класса VirtualizingPanel (класс-предок VirtualizingStackPanel), которые описывают, как списочный элемент будет
                                выполнять виртуализацию. Есть понятие Кэша элементтов CacheLength="10". И тогда непопавшие в область видимости элементы будут кэшированы в указанном количестве (10 шт.)
                                VirtualizationMode="Standard" - контейнеры, попавшие в область видимости рендерятся и создаются на экране, а контейнеры, которые вышли за пределы видимости,
                                скармливаются сборщику мусора и удаляются из памяти.
                                VirtualizationMode="Recycling" - визуальные контейнеры ListBoxItem, которые незримо создаются, выходя за пределы области видимости, не исчезают, а используются повторно
                                для демонстрации нового содержимого. Таким образом на экране будет существовать ограниченное количество (в данном случае 14-16) визуальных элементов ListBoxItem,
                                а все вышедшие за пределы экрана контейнеры будут попадать в кэш, и использоваться повторно для демонстрации нового содержимого. Таким образом, вышеуказанными
                                свойствами можно повысить скорость и регулировать объем памяти, необходимой для визуализации.-->
                                <ListBox.ItemsPanel>
                                    <ItemsPanelTemplate>
                                        <!--<UniformGrid></UniformGrid>-->
                                        <!--<Grid></Grid>-->
                                        <VirtualizingStackPanel/>
                                    </ItemsPanelTemplate>
                                </ListBox.ItemsPanel>
                                <ListBox.ItemTemplate>
                                    <DataTemplate DataType="decanat:Group">
                                        <StackPanel Orientation="Horizontal">
                                            <TextBlock Text="{Binding Name}" Name="TextView"/>
                                            <TextBlock Text="{Binding Students.Count, StringFormat=[Студентов:{0}]}" Margin="3,0,0,0"/>
                                        </StackPanel>
                                        <!--Допустим, что мы хотим, чтобы какая-нибудь группа выделялась другим цветом. У DataTemplate на этот случай есть коллекция триггеров:-->
                                        <DataTemplate.Triggers>
                                            <DataTrigger Binding="{Binding Students.Count}" Value="0">
                                                <Setter TargetName="TextView" Property="Foreground" Value="Red"/>
                                            </DataTrigger>
                                        </DataTemplate.Triggers>
                                    </DataTemplate>
                                </ListBox.ItemTemplate>
                            </ListBox>
                        </DockPanel>
                    </GroupBox>
                    <!--Реализуем второй фильтр для студентов через модель-представления. Вся логика должна быть сосредоточена там, а не так как это было сделано у нас ранее
                    (часть логики работы интерфейса вкладки "Тестирование виртуализации" была вынесена в файл обработчиков собитий исходного кода разметки окна, что не очень хорошо,
                    хотя этим тоже можно пользоваться)-->
                    <GroupBox Grid.Column="1" Header="{Binding SelectedGroup.Name, FallbackValue='Студенты', TargetNullValue='Группа не выбрана'}">
                        <DockPanel>
                            <DockPanel DockPanel.Dock="Top">
                                <DockPanel DockPanel.Dock="Top" Margin="0,3">
                                    <fa:ImageAwesome Height="12" Icon="Solid_Search" Margin="3,0"/>
                                    <!--UpdateSourceTrigger=PropertyChanged - обновление свойства не только при потере фокуса ввода, но и при любом изменении свойства Text:-->
                                    <TextBox Text="{Binding StudentFilterText, UpdateSourceTrigger=PropertyChanged}"/>
                                </DockPanel>
                            </DockPanel>
                            <!--В DataGrid есть свои параметры виртуализации: EnableColumnVirtualization="" и EnableRowVirtualization=""-->
                            <DataGrid ItemsSource="{Binding SelectedGroupStudents}"
                                      AutoGenerateColumns="False"
                                      GridLinesVisibility="Vertical"
                                      VerticalGridLinesBrush="DarkGray"
                                      AlternatingRowBackground="LightGray"
                                      EnableColumnVirtualization="True">
                                <!--<DataGrid.ItemsPanel>
                                    <ItemsPanelTemplate>
                                        <VirtualizingStackPanel></VirtualizingStackPanel>
                                    </ItemsPanelTemplate>
                                </DataGrid.ItemsPanel>-->
                                <!--<DataGrid.GroupStyle>
                                    <GroupStyle/>
                                </DataGrid.GroupStyle>-->
                                <DataGrid.Columns>
                                    <DataGridTextColumn Header="Фамилия" Binding="{Binding Surename}" Width="Auto" IsReadOnly="False"/>
                                    <DataGridTextColumn Header="Имя" Binding="{Binding Name}" IsReadOnly="False"/>
                                    <DataGridTextColumn Header="Отчество"  Binding="{Binding Patronymic}" IsReadOnly="False"/>
                                    <DataGridTextColumn Header="Рейтинг" Binding="{Binding Rating}" IsReadOnly="False"/>
                                    <DataGridTemplateColumn Header="Дата рождения">
                                        <DataGridTemplateColumn.CellTemplate>
                                            <DataTemplate DataType="decanat:Student">
                                                <TextBlock Text="{Binding Birthday, StringFormat='dd.MM.yyyy'}"/>
                                            </DataTemplate>
                                        </DataGridTemplateColumn.CellTemplate>
                                        <DataGridTemplateColumn.CellEditingTemplate>
                                            <DataTemplate DataType="decanat:Student">
                                                <DatePicker SelectedDate="{Binding Birthday}"/>
                                            </DataTemplate>
                                        </DataGridTemplateColumn.CellEditingTemplate>
                                    </DataGridTemplateColumn>
                                    <DataGridTextColumn Header="Заметки" Binding="{Binding Description}" Width="*"/>
                                </DataGrid.Columns>
                            </DataGrid>
                        </DockPanel>
                    </GroupBox>
                </Grid>
            </TabItem>
            <TabItem Header="График" Visibility="Collapsed">
                <!--Предварительно вверху подключим пространство имён OxyPlot: xmlns:oxy="http://oxyplot.org/wpf"-->
                <oxy:Plot>
                    <oxy:Plot.Axes>
                        <oxy:LinearAxis Position="Left"/>
                        <oxy:LinearAxis Position="Bottom"/>
                    </oxy:Plot.Axes>
                    <oxy:LineSeries Color="Red"
                                    ItemsSource="{Binding TestDataPoints}"
                                    DataFieldX="XValue"
                                    DataFieldY="YValue"/>
                </oxy:Plot>


            </TabItem>
            <TabItem Header="Файловая система">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="250"/>
                        <ColumnDefinition/>
                    </Grid.ColumnDefinitions>
                    <GroupBox Grid.Column="0" Header="Директории">
                        <!--<ListBox ItemsSource="{Binding DiskRootDir.DirectoryItems}"
                                 SelectedItem="{Binding SelectedDirectory}"
                                 SelectedIndex="0">
                            <ListBox.ItemTemplate>
                                <DataTemplate DataType="vm:DirectoryViewModel">
                                    <TextBlock Text="{Binding Name}" ToolTip="{Binding CreationTime}"/>
                                </DataTemplate>
                            </ListBox.ItemTemplate>
                        </ListBox>-->
                        <!--TreeView - это компонент, который также представляет собой списочный элемент управления, но у него слегка отличается шаблон. Он позволяет
                        для каждого узла разворачивать или сворачивать содержимое.-->
                        <TreeView ItemsSource="{Binding DiskRootDir.DirectoryItems}">
                            <TreeView.ItemTemplate>
                                <!--<DataTemplate DataType="vm:DirectoryViewModel">
                                    <TextBlock Text="{Binding Name}" ToolTip="{Binding CreationTime}"/>
                                </DataTemplate>-->
                                <!--Обычно для работы с иерархическими данными применяется иерархический шаблон.-->
                                <!--У HierarchicalDataTemplate есть ещё свойство дочерних элементов (ItemSourse). В этом случает появляются разворачивающиеся элементы-->
                                <HierarchicalDataTemplate DataType="vm:DirectoryViewModel"
                                                          ItemsSource="{Binding DirectoryItems}">
                                    <StackPanel Orientation="Horizontal">
                                        <fa:ImageAwesome Height="12" Icon="Regular_Folder" Foreground="Yellow" Margin="0,0,3,0"/>
                                        <TextBlock Text="{Binding Name}"/>
                                    </StackPanel>
                                </HierarchicalDataTemplate>
                            </TreeView.ItemTemplate>
                        </TreeView>
                    </GroupBox>
                    <GroupBox Grid.Column="1" Header="Файлы">
                        <ListBox SelectedItem="{Binding SelectedDirectory.Files, Mode=OneWay}">

                        </ListBox>
                    </GroupBox>
                </Grid>
            </TabItem>
        </TabControl>
    </DockPanel>

</Window>
