using System;
using System.Windows.Input;                 // Для ICommand

namespace CV19.Infrastructure.Commands.Base
{
    // Если проект большой, то класс базовой команды лучше вынести в отдельную библиотеку
    internal abstract class Command : ICommand
    {
        // Реализация интерфейса:
        // 1. Событие. Генерируется в тот момент, когда метод CanExecute начиатет возвращать другое значение, т.е. когда команда переходит из одного состояния в другое
        // Это событие можно вызывать, каким-то своим способом, а можно передать управление этим событием системе WPF.
        // Для этих  целей надо реализовать событие явно (добавить элементы add и remove):
        public event EventHandler CanExecuteChanged
        {
            // В элементе add воспользуемся специальным классом CommnadManager, у которого есть свойство RequerySuggested.
            // Сюда добавляем обработчик событий += value. Аналогично - для remove со знаком "-".
            // Таким оюразом управление событием мы передаём классу CommandManager, и WPF автоматически генерирует это событие у всех команд, когда что-то происходит:
            add => CommandManager.RequerySuggested += value;
            remove => CommandManager.RequerySuggested -= value;
        }


        // Методы. Оба метода делаем абстрактными, и их реализацией займется наследник.
        // 2. Метод 1. Функция, которая возвращает либо истину, либо ложь. Если функция возвращает ложь, то команду выполнить нельзя.
        // Если команду выполнить нельзя, то элемент, который должен выполнить команду, отключается автоматически.
        // Если есть необходимость отключить возможность работы с каким-то визукальным элементом, то у элемента в этом методу нужно начать возвращать ложь:
        public abstract bool CanExecute(object parameter);

        // 3. Метод 2. Основная логика команды (то, что болжно быть выполнено командой):
        public abstract void Execute(object parameter);
    }
}
